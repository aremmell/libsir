.TH "public" 3 "Mon May 29 2023" "Version 2.1.1" "libsir" \" -*- nroff -*-
.ad l
.nh
.SH NAME
public \- Public Interface
.PP
 \- Functions and types that comprise the public interface to libsir\&.  

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsir_stdio_dest\fP"
.br
.RI "Configuration for stdio destinations (stdout and stderr)\&. "
.ti -1c
.RI "struct \fBsir_syslog_dest\fP"
.br
.RI "Configuration for the syslog destination\&. "
.ti -1c
.RI "struct \fBsirinit\fP"
.br
.RI "Initialization data for libsir\&. "
.ti -1c
.RI "struct \fBsirerror\fP"
.br
.RI "Library error type\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef const int * \fBsirfileid_t\fP"
.br
.RI "The file identifier type\&. "
.ti -1c
.RI "typedef uint32_t \fBsirerror_t\fP"
.br
.RI "The error code type\&. "
.ti -1c
.RI "typedef uint16_t \fBsir_levels\fP"
.br
.RI "Used to differentiate between a single \fBsir_level\fP and one or more of them bitwise OR'd together\&. "
.ti -1c
.RI "typedef uint32_t \fBsir_options\fP"
.br
.RI "Used to differentiate between a single \fBsir_option\fP and one or more bitwise OR'd together\&. "
.ti -1c
.RI "typedef char \fBsirchar_t\fP"
.br
.RI "The underlying type used for characters in output\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBsir_level\fP { \fBSIRL_NONE\fP = 0x0000, \fBSIRL_EMERG\fP = 0x0001, \fBSIRL_ALERT\fP = 0x0002, \fBSIRL_CRIT\fP = 0x0004, \fBSIRL_ERROR\fP = 0x0008, \fBSIRL_WARN\fP = 0x0010, \fBSIRL_NOTICE\fP = 0x0020, \fBSIRL_INFO\fP = 0x0040, \fBSIRL_DEBUG\fP = 0x0080, \fBSIRL_ALL\fP = 0x00ff, \fBSIRL_DEFAULT\fP = 0x0100 }"
.br
.RI "Defines the available levels \fI\fP(severity/priority) of logging output\&. "
.ti -1c
.RI "enum \fBsir_option\fP { \fBSIRO_ALL\fP = 0x00000000, \fBSIRO_NOTIME\fP = 0x00000200, \fBSIRO_NOLEVEL\fP = 0x00000400, \fBSIRO_NONAME\fP = 0x00000800, \fBSIRO_NOMSEC\fP = 0x00001000, \fBSIRO_NOPID\fP = 0x00002000, \fBSIRO_NOTID\fP = 0x00004000, \fBSIRO_NOHDR\fP = 0x00010000, \fBSIRO_MSGONLY\fP = 0x000eff00, \fBSIRO_DEFAULT\fP = 0x00100000 }"
.br
.RI "Formatting options for a destination\&. "
.ti -1c
.RI "enum \fBsir_textstyle\fP { \fBSIRS_NONE\fP = 0x00000000, \fBSIRS_BRIGHT\fP = 0x00000001, \fBSIRS_DIM\fP = 0x00000002, \fBSIRS_FG_BLACK\fP = 0x00000010, \fBSIRS_FG_RED\fP = 0x00000020, \fBSIRS_FG_GREEN\fP = 0x00000030, \fBSIRS_FG_YELLOW\fP = 0x00000040, \fBSIRS_FG_BLUE\fP = 0x00000050, \fBSIRS_FG_MAGENTA\fP = 0x00000060, \fBSIRS_FG_CYAN\fP = 0x00000070, \fBSIRS_FG_DEFAULT\fP = 0x00000080, \fBSIRS_FG_LGRAY\fP = 0x00000090, \fBSIRS_FG_DGRAY\fP = 0x000000a0, \fBSIRS_FG_LRED\fP = 0x000000b0, \fBSIRS_FG_LGREEN\fP = 0x000000c0, \fBSIRS_FG_LYELLOW\fP = 0x000000d0, \fBSIRS_FG_LBLUE\fP = 0x000000e0, \fBSIRS_FG_LMAGENTA\fP = 0x000000f0, \fBSIRS_FG_LCYAN\fP = 0x00000f10, \fBSIRS_FG_WHITE\fP = 0x00000f20, \fBSIRS_BG_BLACK\fP = 0x00001000, \fBSIRS_BG_RED\fP = 0x00002000, \fBSIRS_BG_GREEN\fP = 0x00003000, \fBSIRS_BG_YELLOW\fP = 0x00004000, \fBSIRS_BG_BLUE\fP = 0x00005000, \fBSIRS_BG_MAGENTA\fP = 0x00006000, \fBSIRS_BG_CYAN\fP = 0x00007000, \fBSIRS_BG_DEFAULT\fP = 0x00008000, \fBSIRS_BG_LGRAY\fP = 0x00009000, \fBSIRS_BG_DGRAY\fP = 0x0000a000, \fBSIRS_BG_LRED\fP = 0x0000b000, \fBSIRS_BG_LGREEN\fP = 0x0000c000, \fBSIRS_BG_LYELLOW\fP = 0x0000d000, \fBSIRS_BG_LBLUE\fP = 0x0000e000, \fBSIRS_BG_LMAGENTA\fP = 0x0000f000, \fBSIRS_BG_LCYAN\fP = 0x000f1000, \fBSIRS_BG_WHITE\fP = 0x000f2000, \fBSIRS_INVALID\fP = 0x000f3000 }"
.br
.RI "Styles for 16-color console output\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBsir_init\fP (\fBsirinit\fP *si)"
.br
.RI "Initializes libsir\&. "
.ti -1c
.RI "bool \fBsir_stdoutlevels\fP (\fBsir_levels\fP levels)"
.br
.RI "Sets levels sent to \fIstdout\fP\&. "
.ti -1c
.RI "bool \fBsir_stdoutopts\fP (\fBsir_options\fP opts)"
.br
.RI "Sets formatting options for \fIstdout\fP\&. "
.ti -1c
.RI "bool \fBsir_stderrlevels\fP (\fBsir_levels\fP levels)"
.br
.RI "Sets levels sent to \fIstderr\fP\&. "
.ti -1c
.RI "bool \fBsir_stderropts\fP (\fBsir_options\fP opts)"
.br
.RI "Sets formatting options for \fIstderr\fP\&. "
.ti -1c
.RI "bool \fBsir_sysloglevels\fP (\fBsir_levels\fP levels)"
.br
.RI "Sets levels sent to \fIsyslog\fP (if available)\&. "
.ti -1c
.RI "bool \fBsir_filelevels\fP (\fBsirfileid_t\fP id, \fBsir_levels\fP levels)"
.br
.RI "Sets levels sent to a log file\&. "
.ti -1c
.RI "bool \fBsir_fileopts\fP (\fBsirfileid_t\fP id, \fBsir_options\fP opts)"
.br
.RI "Sets formatting options for a log file\&. "
.ti -1c
.RI "bool \fBsir_cleanup\fP (void)"
.br
.RI "Frees allocated resources and resets internal state\&. "
.ti -1c
.RI "bool \fBsir_debug\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted debug-level message\&. "
.ti -1c
.RI "bool \fBsir_info\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted informational message\&. "
.ti -1c
.RI "bool \fBsir_notice\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted notice message\&. "
.ti -1c
.RI "bool \fBsir_warn\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted warning message\&. "
.ti -1c
.RI "bool \fBsir_error\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted error message\&. "
.ti -1c
.RI "bool \fBsir_crit\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted critical error message\&. "
.ti -1c
.RI "bool \fBsir_alert\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted alert message\&. "
.ti -1c
.RI "bool \fBsir_emerg\fP (const \fBsirchar_t\fP *format,\&.\&.\&.)"
.br
.RI "Log a formatted emergency message\&. "
.ti -1c
.RI "\fBsirfileid_t\fP \fBsir_addfile\fP (const \fBsirchar_t\fP *path, \fBsir_levels\fP levels, \fBsir_options\fP opts)"
.br
.RI "Add a log file to receive formatted output for one or more \fBsir_level\fP\&. "
.ti -1c
.RI "bool \fBsir_remfile\fP (\fBsirfileid_t\fP id)"
.br
.RI "Remove a previously added log file\&. "
.ti -1c
.RI "bool \fBsir_settextstyle\fP (\fBsir_level\fP level, \fBsir_textstyle\fP style)"
.br
.RI "Sets the text style in \fIstdio\fP output for a \fBsir_level\fP of output\&. "
.ti -1c
.RI "bool \fBsir_resettextstyles\fP (void)"
.br
.RI "Resets all \fIstdio\fP text styles to their default values\&. "
.in -1c
.SH "Detailed Description"
.PP 
Functions and types that comprise the public interface to libsir\&. 


.SH "Data Structure Documentation"
.PP 
.SH "struct sir_stdio_dest"
.PP 
Configuration for stdio destinations (stdout and stderr)\&. 
.PP
Definition at line \fB139\fP of file \fBsirtypes\&.h\fP\&.
.SH "struct sir_syslog_dest"
.PP 
Configuration for the syslog destination\&. 
.PP
Definition at line \fB148\fP of file \fBsirtypes\&.h\fP\&.
.SH "struct sirinit"
.PP 
Initialization data for libsir\&. 

Allocate an instance of this struct and pass it to \fBsir_init\fP in order to begin using libsir\&. 
.PP
Definition at line \fB166\fP of file \fBsirtypes\&.h\fP\&.
.PP
\fBData Fields:\fP
.RS 4
\fBsir_stdio_dest\fP \fId_stderr\fP stderr configuration\&. 
.br
.PP
\fBsir_stdio_dest\fP \fId_stdout\fP stdout configuration\&. 
.br
.PP
\fBsir_syslog_dest\fP \fId_syslog\fP syslog configuration (if available)\&. 
.br
.PP
\fBsirchar_t\fP \fIprocessName[32]\fP If set, defines the name that will appear in formatted output\&. 
.br
Set \fBSIRO_NONAME\fP for a destination to supppress it\&. 
.br
.PP
.RE
.PP
.SH "struct sirerror"
.PP 
Library error type\&. 
.PP
Definition at line \fB177\fP of file \fBsirtypes\&.h\fP\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBsir_level\fP"

.PP
Defines the available levels \fI\fP(severity/priority) of logging output\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISIRL_NONE \fP\fP
No output\&. 
.TP
\fB\fISIRL_EMERG \fP\fP
Nuclear war, Armageddon, etc\&. 
.TP
\fB\fISIRL_ALERT \fP\fP
Action required ASAP\&. 
.TP
\fB\fISIRL_CRIT \fP\fP
Critical errors\&. 
.TP
\fB\fISIRL_ERROR \fP\fP
Errors\&. 
.TP
\fB\fISIRL_WARN \fP\fP
Warnings that could likely be ignored\&. 
.TP
\fB\fISIRL_NOTICE \fP\fP
Normal but significant\&. 
.TP
\fB\fISIRL_INFO \fP\fP
Informational messages\&. 
.TP
\fB\fISIRL_DEBUG \fP\fP
Debugging/diagnostic output\&. 
.TP
\fB\fISIRL_ALL \fP\fP
Includes all logging levels\&. 
.TP
\fB\fISIRL_DEFAULT \fP\fP
Use the default levels for this type of destination\&. 
.PP
Definition at line \fB50\fP of file \fBsirtypes\&.h\fP\&.
.SS "enum \fBsir_option\fP"

.PP
Formatting options for a destination\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISIRO_ALL \fP\fP
Effectively = \fBSIRO_MSGONLY\fP\&. 
.TP
\fB\fISIRO_NOTIME \fP\fP
Exclude time stamps (implies \fBSIRO_NOMSEC\fP)\&. 
.TP
\fB\fISIRO_NOLEVEL \fP\fP
Exclude human-readable logging level\&. 
.TP
\fB\fISIRO_NONAME \fP\fP
Exclude process/app name\&. 
.TP
\fB\fISIRO_NOMSEC \fP\fP
Exclude millisecond-resolution in time stamps\&. 
.TP
\fB\fISIRO_NOPID \fP\fP
Exclude process ID (does not imply \fBSIRO_NOTID\fP)\&. 
.TP
\fB\fISIRO_NOTID \fP\fP
Exclude thread ID/name\&. 
.TP
\fB\fISIRO_NOHDR \fP\fP
Don't write header messages to log files\&. 
.TP
\fB\fISIRO_MSGONLY \fP\fP
Sets all other options except \fBSIRO_NOHDR\fP\&. 
.TP
\fB\fISIRO_DEFAULT \fP\fP
Use the default options for this type of destination\&. 
.PP
Definition at line \fB71\fP of file \fBsirtypes\&.h\fP\&.
.SS "enum \fBsir_textstyle\fP"

.PP
Styles for 16-color console output\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISIRS_NONE \fP\fP
Used internally; has no effect\&. 
.TP
\fB\fISIRS_BRIGHT \fP\fP
If set, the foreground color is 'intensified'\&. 
.TP
\fB\fISIRS_DIM \fP\fP
If set, the foreground color is 'dimmed'\&. 
.TP
\fB\fISIRS_FG_BLACK \fP\fP
Black foreground\&. 
.TP
\fB\fISIRS_FG_RED \fP\fP
Red foreground\&. 
.TP
\fB\fISIRS_FG_GREEN \fP\fP
Green foreground\&. 
.TP
\fB\fISIRS_FG_YELLOW \fP\fP
Yellow foreground\&. 
.TP
\fB\fISIRS_FG_BLUE \fP\fP
Blue foreground\&. 
.TP
\fB\fISIRS_FG_MAGENTA \fP\fP
Magenta foreground\&. 
.TP
\fB\fISIRS_FG_CYAN \fP\fP
Cyan foreground\&. 
.TP
\fB\fISIRS_FG_DEFAULT \fP\fP
Use the default foreground color\&. 
.TP
\fB\fISIRS_FG_LGRAY \fP\fP
Light gray foreground\&. 
.TP
\fB\fISIRS_FG_DGRAY \fP\fP
Dark gray foreground\&. 
.TP
\fB\fISIRS_FG_LRED \fP\fP
Light red foreground\&. 
.TP
\fB\fISIRS_FG_LGREEN \fP\fP
Light green foreground\&. 
.TP
\fB\fISIRS_FG_LYELLOW \fP\fP
Light yellow foreground\&. 
.TP
\fB\fISIRS_FG_LBLUE \fP\fP
Light blue foreground\&. 
.TP
\fB\fISIRS_FG_LMAGENTA \fP\fP
Light magenta foreground\&. 
.TP
\fB\fISIRS_FG_LCYAN \fP\fP
Light cyan foreground\&. 
.TP
\fB\fISIRS_FG_WHITE \fP\fP
White foreground\&. 
.TP
\fB\fISIRS_BG_BLACK \fP\fP
Black background\&. 
.TP
\fB\fISIRS_BG_RED \fP\fP
Red background\&. 
.TP
\fB\fISIRS_BG_GREEN \fP\fP
Green background\&. 
.TP
\fB\fISIRS_BG_YELLOW \fP\fP
Yellow background\&. 
.TP
\fB\fISIRS_BG_BLUE \fP\fP
Blue background\&. 
.TP
\fB\fISIRS_BG_MAGENTA \fP\fP
Magenta background\&. 
.TP
\fB\fISIRS_BG_CYAN \fP\fP
Cyan background\&. 
.TP
\fB\fISIRS_BG_DEFAULT \fP\fP
Use the default background color\&. 
.TP
\fB\fISIRS_BG_LGRAY \fP\fP
Light gray background\&. 
.TP
\fB\fISIRS_BG_DGRAY \fP\fP
Dark gray background\&. 
.TP
\fB\fISIRS_BG_LRED \fP\fP
Light red background\&. 
.TP
\fB\fISIRS_BG_LGREEN \fP\fP
Light green background\&. 
.TP
\fB\fISIRS_BG_LYELLOW \fP\fP
Light yellow background\&. 
.TP
\fB\fISIRS_BG_LBLUE \fP\fP
Light blue background\&. 
.TP
\fB\fISIRS_BG_LMAGENTA \fP\fP
Light magenta background\&. 
.TP
\fB\fISIRS_BG_LCYAN \fP\fP
Light cyan background\&. 
.TP
\fB\fISIRS_BG_WHITE \fP\fP
White background\&. 
.TP
\fB\fISIRS_INVALID \fP\fP
Represents the invalid text style\&. 
.PP
Definition at line \fB91\fP of file \fBsirtypes\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "\fBsirfileid_t\fP sir_addfile (const \fBsirchar_t\fP * path, \fBsir_levels\fP levels, \fBsir_options\fP opts)"

.PP
Add a log file to receive formatted output for one or more \fBsir_level\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP The absolute or relative path to the file\&. If it does not exist, it will be created\&. 
.br
\fIlevels\fP One or more \fBsir_level\fP for which the file should be sent output\&. Use \fBSIRL_ALL\fP to send all logging levels to the file\&. 
.br
\fIopts\fP Zero or more \fBsir_option\fP flags used to control output formatting\&.
.RE
.PP
\fBAttention\fP
.RS 4
The sirfileid_t type is a pointer to the internally mapped file descriptor for a file\&. If you modify the value at this address, the behavior is undefined, and bad things will happen\&.
.RE
.PP
\fBReturns\fP
.RS 4
sirfileid_t 
.RE
.PP
\fBReturn values\fP
.RS 4
\fIThe\fP file descriptor for the file that was successfully added\&. 
.br
\fINULL\fP An error occurred while trying to add the file\&. 
.RE
.PP

.PP
Definition at line \fB159\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_alert (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted alert message\&. This function maps internally to the logging level \fBSIRL_ALERT\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB145\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_cleanup (void)"

.PP
Frees allocated resources and resets internal state\&. 
.PP
\fBRemarks\fP
.RS 4
Call \fBsir_init\fP to initialize libsir\&.
.PP
It is not necessary to call this function from the same thread that called \fBsir_init\fP\&. Any calls made after this to functions other than to \fBsir_init\fP \fI\fP(in order to re-initialize) will fail\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP libsir is cleaned up\&. 
.br
\fIfalse\fP An error occurred\&. 
.RE
.PP

.PP
Definition at line \fB95\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_crit (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted critical error message\&. This function maps internally to the logging level \fBSIRL_CRIT\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB138\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_debug (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted debug-level message\&. This function maps internally to the logging level \fBSIRL_DEBUG\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB103\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_emerg (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted emergency message\&. This function maps internally to the logging level \fBSIRL_EMERG\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB152\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_error (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted error message\&. This function maps internally to the logging level \fBSIRL_ERROR\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB131\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_filelevels (\fBsirfileid_t\fP id, \fBsir_levels\fP levels)"

.PP
Sets levels sent to a log file\&. Sets the \fBsir_level\fP registration mask for this destination\&.
.PP
\fBSee also\fP
.RS 4
\fBsir_fileopts\fP 
.PP
\fBsir_geterror\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIid\fP The identifier returned from \fBsir_addfile\fP\&. 
.br
\fIlevels\fP \fBsir_level\fP flags\&.
.RE
.PP
Value   Behavior    \fCSIRL_NONE\fP   No levels\&.    \fCSIRL_ALL\fP   All levels\&.    \fCSIRL_DEFAULT\fP   Revert to the default (\fBsirdefaults\&.h\fP)\&.    \fCSIRL_*\fP   Register for each level set\&.   
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP Levels were updated successfully\&. 
.br
\fIfalse\fP An error occurred while trying to update levels\&. 
.RE
.PP

.PP
Definition at line \fB83\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_fileopts (\fBsirfileid_t\fP id, \fBsir_options\fP opts)"

.PP
Sets formatting options for a log file\&. Sets the \fBsir_option\fP mask that controls the content of messages sent to this destination\&.
.PP
\fBSee also\fP
.RS 4
\fBsir_filelevels\fP 
.PP
\fBsir_geterror\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIid\fP The identifier returned from \fBsir_addfile\fP\&. 
.br
\fIopts\fP \fBsir_option\fP flags\&.
.RE
.PP
Value   Behavior    \fC0\fP   Include all available data\&.    \fCSIRO_DEFAULT\fP   Revert to the default (\fBsirdefaults\&.h\fP)\&.    \fCSIRO_*\fP   Apply each option set\&.   
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP Options were updated successfully\&. 
.br
\fIfalse\fP An error occurred while trying to update options\&. 
.RE
.PP

.PP
Definition at line \fB89\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_info (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted informational message\&. This function maps internally to the logging level \fBSIRL_INFO\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB110\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_init (\fBsirinit\fP * si)"

.PP
Initializes libsir\&. Any thread may initialize SIR, but any calls to other libsir functions will fail until this call has completed\&.
.PP
\fBRemarks\fP
.RS 4
Call \fBsir_cleanup\fP when you're through\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIsi\fP Initialization options\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP libsir is initialized and ready to use\&. 
.br
\fIfalse\fP Initialization failed\&. 
.RE
.PP

.PP
Definition at line \fB44\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_notice (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted notice message\&. This function maps internally to the logging level \fBSIRL_NOTICE\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB117\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_remfile (\fBsirfileid_t\fP id)"

.PP
Remove a previously added log file\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP The file descriptor returned from \fBsir_addfile\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP The file was removed and will no longer receive output\&. 
.br
\fIfalse\fP An error occurred while trying to remove the file\&. 
.RE
.PP

.PP
Definition at line \fB163\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_resettextstyles (void)"

.PP
Resets all \fIstdio\fP text styles to their default values\&. 
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All text styles were reset to their defaults\&. 
.br
\fIfalse\fP An error occurred while trying to reset text styles\&. 
.RE
.PP

.PP
Definition at line \fB171\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_settextstyle (\fBsir_level\fP level, \fBsir_textstyle\fP style)"

.PP
Sets the text style in \fIstdio\fP output for a \fBsir_level\fP of output\&. 
.PP
\fBParameters\fP
.RS 4
\fIlevel\fP The level \fI\fP(only one is permitted per call) for which the style will be set\&. 
.br
\fIstyle\fP Foreground color, background color, and brightness control flags bitwise OR'd to create the text style for \fClevel\fP\&. See \fBsir_textstyle\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP The style is valid and was applied\&. 
.br
\fIfalse\fP An error occurred while trying to set the text style\&. 
.RE
.PP

.PP
Definition at line \fB167\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_stderrlevels (\fBsir_levels\fP levels)"

.PP
Sets levels sent to \fIstderr\fP\&. Sets the \fBsir_level\fP registration mask for this destination\&.
.PP
\fBSee also\fP
.RS 4
\fBsir_stderropts\fP 
.PP
\fBsir_geterror\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlevels\fP \fBsir_level\fP flags\&.
.RE
.PP
Value   Behavior    \fCSIRL_NONE\fP   No levels\&.    \fCSIRL_ALL\fP   All levels\&.    \fCSIRL_DEFAULT\fP   Revert to the default (\fBsirdefaults\&.h\fP)\&.    \fCSIRL_*\fP   Register for each level set\&.   
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP Levels were updated successfully\&. 
.br
\fIfalse\fP An error occurred while trying to update levels\&. 
.RE
.PP

.PP
Definition at line \fB60\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_stderropts (\fBsir_options\fP opts)"

.PP
Sets formatting options for \fIstderr\fP\&. Sets the \fBsir_option\fP mask that controls the content of messages sent to this destination\&.
.PP
\fBSee also\fP
.RS 4
\fBsir_stderrlevels\fP 
.PP
\fBsir_geterror\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIopts\fP \fBsir_option\fP flags\&.
.RE
.PP
Value   Behavior    \fC0\fP   Include all available data\&.    \fCSIRO_DEFAULT\fP   Revert to the default (\fBsirdefaults\&.h\fP)\&.    \fCSIRO_*\fP   Apply each option set\&.   
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP Options were updated successfully\&. 
.br
\fIfalse\fP An error occurred while trying to update options\&. 
.RE
.PP

.PP
Definition at line \fB66\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_stdoutlevels (\fBsir_levels\fP levels)"

.PP
Sets levels sent to \fIstdout\fP\&. Sets the \fBsir_level\fP registration mask for this destination\&.
.PP
\fBSee also\fP
.RS 4
\fBsir_stdoutopts\fP 
.PP
\fBsir_geterror\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlevels\fP \fBsir_level\fP flags\&.
.RE
.PP
Value   Behavior    \fCSIRL_NONE\fP   No levels\&.    \fCSIRL_ALL\fP   All levels\&.    \fCSIRL_DEFAULT\fP   Revert to the default (\fBsirdefaults\&.h\fP)\&.    \fCSIRL_*\fP   Register for each level set\&.   
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP Levels were updated successfully\&. 
.br
\fIfalse\fP An error occurred while trying to update levels\&. 
.RE
.PP

.PP
Definition at line \fB48\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_stdoutopts (\fBsir_options\fP opts)"

.PP
Sets formatting options for \fIstdout\fP\&. Sets the \fBsir_option\fP mask that controls the content of messages sent to this destination\&.
.PP
\fBSee also\fP
.RS 4
\fBsir_stdoutlevels\fP 
.PP
\fBsir_geterror\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIopts\fP \fBsir_option\fP flags\&.
.RE
.PP
Value   Behavior    \fC0\fP   Include all available data\&.    \fCSIRO_DEFAULT\fP   Revert to the default (\fBsirdefaults\&.h\fP)\&.    \fCSIRO_*\fP   Apply each option set\&.   
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP Options were updated successfully\&. 
.br
\fIfalse\fP An error occurred while trying to update options\&. 
.RE
.PP

.PP
Definition at line \fB54\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_sysloglevels (\fBsir_levels\fP levels)"

.PP
Sets levels sent to \fIsyslog\fP (if available)\&. Sets the \fBsir_level\fP registration mask for this destination\&.
.PP
\fBAttention\fP
.RS 4
If \fCSIR_NOSYSLOG\fP is defined upon compilation, returns \fCfalse\fP and has no effect\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBsir_geterror\fP 
.RE
.PP
\fBParameters\fP
.RS 4
\fIlevels\fP \fBsir_level\fP flags\&.
.RE
.PP
Value   Behavior    \fCSIRL_NONE\fP   No levels\&.    \fCSIRL_ALL\fP   All levels\&.    \fCSIRL_DEFAULT\fP   Revert to the default (\fBsirdefaults\&.h\fP)\&.    \fCSIRL_*\fP   Register for each level set\&.   
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP Levels were updated successfully\&. 
.br
\fIfalse\fP An error occurred while trying to update levels\&. 
.RE
.PP

.PP
Definition at line \fB72\fP of file \fBsir\&.c\fP\&.
.SS "bool sir_warn (const \fBsirchar_t\fP * format,  \&.\&.\&.)"

.PP
Log a formatted warning message\&. This function maps internally to the logging level \fBSIRL_WARN\fP\&.
.PP
\fBParameters\fP
.RS 4
\fIformat\fP A printf-style format string\&. 
.br
\fI\&.\&.\&.\fP \fI\fP(variadic) Additional arguments whose types correspond to the format specifier at the same index in \fCformat\fP\&.
.RE
.PP
\fBReturns\fP
.RS 4
boolean 
.RE
.PP
\fBReturn values\fP
.RS 4
\fItrue\fP All destinations registered for this level were successfully processed\&. 
.br
\fIfalse\fP One or more destinations were not successfully processed\&. 
.RE
.PP

.PP
Definition at line \fB124\fP of file \fBsir\&.c\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libsir from the source code\&.
