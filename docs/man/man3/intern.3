.TH "intern" 3 "Mon May 29 2023" "Version 2.1.1" "libsir" \" -*- nroff -*-
.ad l
.nh
.SH NAME
intern \- Internal
.PP
 \- libsir's guts\&.  

.SH SYNOPSIS
.br
.PP
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBsirfile\fP"
.br
.RI "Log file data\&. "
.ti -1c
.RI "struct \fBsirfcache\fP"
.br
.RI "Log file cache\&. "
.ti -1c
.RI "struct \fBsirbuf\fP"
.br
.RI "Formatted output sent to destinations\&. "
.ti -1c
.RI "struct \fBsir_level_style_pair\fP"
.br
.RI "\fBsir_level\fP <-> default \fBsir_textstyle\fP mapping\&. "
.ti -1c
.RI "struct \fBsir_level_str_pair\fP"
.br
.RI "\fBsir_level\fP <-> string representation mapping (\fBsirconfig\&.h\fP) "
.ti -1c
.RI "struct \fBsir_style_16color_pair\fP"
.br
.RI "Public (\fBsir_textstyle\fP) <-> values used to generate styled terminal output\&. "
.ti -1c
.RI "struct \fBsir_thread_err\fP"
.br
.RI "Error type\&. "
.ti -1c
.RI "struct \fBsir_update_config_data\fP"
.br
.RI "Encapsulates dynamic updating of current configuration\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB_sir_countof\fP(arr)   (sizeof(arr) / sizeof(arr[0]))"
.br
.RI "Computes the size of an array\&. "
.ti -1c
.RI "#define \fB_sir_mkerror\fP(code)       (((uint32_t)(code & 0x7fff) << 16) | 0x80000000)"
.br
.RI "Creates an error code that (hopefully) doesn't conflict with any of those defined by the platform\&. "
.ti -1c
.RI "#define \fB_SIR_L_START\fP(format)"
.br
.RI "Evil macro used for _sir_lv wrappers\&. "
.ti -1c
.RI "#define \fB_SIR_L_END\fP(args)   va_end(args);"
.br
.RI "Evil macro used for _sir_lv wrappers\&. "
.ti -1c
.RI "#define \fB_SIR_UNUSED\fP(param)   (void)param;"
.br
.RI "Squelches warnings about unreferenced parameters\&. "
.ti -1c
.RI "#define \fB_SIR_DECLARE_BIN_SEARCH\fP(low,  high)"
.br
.RI "Even more evil macros used for binary searching arrays\&. "
.ti -1c
.RI "#define \fB_sir_notnull\fP(addr)   (NULL != addr)"
.br
.RI "Validates a pointer-to-pointer, pointer, pointer to function, etc\&. "
.ti -1c
.RI "#define \fBSIR_ESC_START\fP   '\\x1b['"
.br
.RI "Escape sequences: "
.ti -1c
.RI "#define \fBSIR_R_ARROW\fP   '\\xe2\\x86\\x92'"
.br
.RI "A couple fun characters that can be sent to stdio\&. "
.ti -1c
.RI "#define \fB_SIRS_ATTR_MASK\fP   0x0000000f"
.br
.RI "Text style attribute mask\&. "
.ti -1c
.RI "#define \fB_SIRS_FG_MASK\fP   0x00000ff0"
.br
.RI "Text style foreground color mask\&. "
.ti -1c
.RI "#define \fB_SIRS_BG_MASK\fP   0x000ff000"
.br
.RI "Text style background color mask\&. "
.ti -1c
.RI "#define \fB_SIRS_SAME_COLOR\fP(fg,  bg)   (((bg >> 8) & \fB_SIRS_FG_MASK\fP) == fg)"
.br
.RI "True if foreground and background colors are the same\&. "
.ti -1c
.RI "#define \fB_SIR_MAGIC\fP   0x60906090"
.br
.RI "Magic number used to determine if libsir has been initialized\&. "
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBsirinit_update\fP) (\fBsirinit\fP *, \fBsir_update_config_data\fP *)"
.br
.RI "Updates levels/options in the global init structure\&. "
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBsir_mutex_id\fP { \fB_SIRM_INIT\fP = 0, \fB_SIRM_FILECACHE\fP, \fB_SIRM_TEXTSTYLE\fP }"
.br
.RI "Mutex <-> protected section mapping\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fB_sirfile_archive\fP (\fBsirfile\fP *sf, const \fBsirchar_t\fP *newpath)"
.br
.ti -1c
.RI "bool \fB_sir_fileexists\fP (const char *restrict path)"
.br
.RI "Determines if a file or directory exists in the filesystem\&. "
.ti -1c
.RI "bool \fB_sir_getcwd\fP (char *restrict buffer, size_t size)"
.br
.RI "Obtains the current working directory for the calling process\&. "
.ti -1c
.RI "bool \fB_sir_validfid\fP (int id)"
.br
.RI "Validates a log file identifier\&. "
.ti -1c
.RI "bool \fB_sir_validupdatedata\fP (\fBsir_update_config_data\fP *data)"
.br
.RI "Validates a \fBsir_update_config_data\fP structure\&. "
.ti -1c
.RI "bool \fB_sir_validlevels\fP (\fBsir_levels\fP levels)"
.br
.RI "Validates a set of \fBsir_level\fP flags\&. "
.ti -1c
.RI "bool \fB_sir_validlevel\fP (\fBsir_level\fP level)"
.br
.RI "Validates a single \fBsir_level\fP\&. "
.ti -1c
.RI "bool \fB_sir_validopts\fP (\fBsir_options\fP opts)"
.br
.RI "Validates a set of \fBsir_option\fP flags\&. "
.ti -1c
.RI "bool \fB__sir_validstr\fP (const \fBsirchar_t\fP *str, bool fail)"
.br
.RI "Validates a string pointer and optionally fails if it's invalid\&. "
.ti -1c
.RI "bool \fB__sir_validptr\fP (const void *restrict p, bool fail)"
.br
.RI "Validates a pointer and optionally fails if it's invalid\&. "
.ti -1c
.RI "int \fB_sir_strncpy\fP (\fBsirchar_t\fP *restrict dest, size_t destsz, const \fBsirchar_t\fP *restrict src, size_t count)"
.br
.RI "Wrapper for strncpy/strncpy_s\&. "
.ti -1c
.RI "int \fB_sir_strncat\fP (\fBsirchar_t\fP *restrict dest, size_t destsz, const \fBsirchar_t\fP *restrict src, size_t count)"
.br
.RI "Wrapper for strncat/strncat_s\&. "
.ti -1c
.RI "int \fB_sir_fopen\fP (FILE *restrict *restrict streamptr, const \fBsirchar_t\fP *restrict filename, const \fBsirchar_t\fP *restrict mode)"
.br
.RI "Wrapper for fopen/fopen_s\&. "
.ti -1c
.RI "struct tm * \fB_sir_localtime\fP (const time_t *restrict timer, struct tm *restrict buf)"
.br
.RI "Wrapper for localtime/localtime_s\&. "
.ti -1c
.RI "int \fB_sir_getchar\fP (void)"
.br
.RI "A portable 'press any key to continue' implementation; On Windows, uses _getch()\&. "
.ti -1c
.RI "static bool \fB_sir_validerror\fP (\fBsirerror_t\fP err)"
.br
.RI "Validates an internal error\&. "
.ti -1c
.RI "static uint16_t \fB_sir_geterrcode\fP (\fBsirerror_t\fP err)"
.br
.RI "Extracts just the code from an internal error\&. "
.ti -1c
.RI "static bool \fB_sir_bittest\fP (uint32_t flags, uint32_t test)"
.br
.RI "Checks a bitfield for a specific set of bits\&. "
.ti -1c
.RI "static void \fB__sir_safefree\fP (void **p)"
.br
.RI "Wraps \fIfree\fP\&. "
.ti -1c
.RI "static void \fB_sir_safefree\fP (void *p)"
.br
.RI "Wraps \fIfree\fP\&. "
.ti -1c
.RI "static void \fB_sir_defaultlevels\fP (\fBsir_levels\fP *levels, \fBsir_levels\fP def)"
.br
.RI "Applies default \fBsir_level\fP flags if applicable\&. "
.ti -1c
.RI "static void \fB_sir_defaultopts\fP (\fBsir_options\fP *opts, \fBsir_options\fP def)"
.br
.RI "Applies default \fBsir_options\fP flags if applicable\&. "
.ti -1c
.RI "static bool \fB_sir_validstr\fP (const \fBsirchar_t\fP *str)"
.br
.RI "Validates a string pointer and fails if it's invalid\&. "
.ti -1c
.RI "static bool \fB_sir_validstrnofail\fP (const \fBsirchar_t\fP *str)"
.br
.RI "Validates a string pointer but ignores whether it's invalid\&. "
.ti -1c
.RI "static bool \fB_sir_validptr\fP (const void *restrict p)"
.br
.RI "Validates a pointer and fails if it's invalid\&. "
.ti -1c
.RI "static bool \fB_sir_validptrnofail\fP (const void *restrict p)"
.br
.RI "Validates a pointer but ignores whether it's invalid\&. "
.ti -1c
.RI "static void \fB_sir_resetstr\fP (\fBsirchar_t\fP *str)"
.br
.RI "Places a null terminator at the first index in a string buffer\&. "
.ti -1c
.RI "bool \fB_sir_sanity\fP (void)"
.br
.RI "Evaluates whether or not libsir has been initialized\&. "
.ti -1c
.RI "bool \fB_sir_options_sanity\fP (const \fBsirinit\fP *si)"
.br
.RI "Validates the configuration passed to \fBsir_init\fP\&. "
.ti -1c
.RI "bool \fB_sir_init\fP (\fBsirinit\fP *si)"
.br
.RI "Initializes libsir\&. "
.ti -1c
.RI "void \fB_sir_stdoutlevels\fP (\fBsirinit\fP *si, \fBsir_update_config_data\fP *data)"
.br
.RI "Updates levels for \fIstdout\fP\&. "
.ti -1c
.RI "void \fB_sir_stdoutopts\fP (\fBsirinit\fP *si, \fBsir_update_config_data\fP *data)"
.br
.RI "Updates options for \fIstdout\fP\&. "
.ti -1c
.RI "void \fB_sir_stderrlevels\fP (\fBsirinit\fP *si, \fBsir_update_config_data\fP *data)"
.br
.RI "Updates levels for \fIstderr\fP\&. "
.ti -1c
.RI "void \fB_sir_stderropts\fP (\fBsirinit\fP *si, \fBsir_update_config_data\fP *data)"
.br
.RI "Updates options for \fIstderr\fP\&. "
.ti -1c
.RI "void \fB_sir_sysloglevels\fP (\fBsirinit\fP *si, \fBsir_update_config_data\fP *data)"
.br
.RI "Updates levels for \fIsyslog\fP\&. "
.ti -1c
.RI "bool \fB_sir_writeinit\fP (\fBsir_update_config_data\fP *data, \fBsirinit_update\fP update)"
.br
.RI "Updates levels/options in the global init structure\&. "
.ti -1c
.RI "void * \fB_sir_locksection\fP (\fBsir_mutex_id\fP mid)"
.br
.RI "Locks a protected section\&. "
.ti -1c
.RI "bool \fB_sir_unlocksection\fP (\fBsir_mutex_id\fP mid)"
.br
.RI "Unlocks a protected section\&. "
.ti -1c
.RI "bool \fB_sir_mapmutexid\fP (\fBsir_mutex_id\fP mid, \fBsirmutex_t\fP **m, void **section)"
.br
.RI "Maps a \fBsir_mutex_id\fP to a \fBsirmutex_t\fP and protected section\&. "
.ti -1c
.RI "bool \fB_sir_cleanup\fP (void)"
.br
.RI "Frees allocated resources\&. "
.ti -1c
.RI "void \fB_sir_initialize_once\fP (void)"
.br
.RI "General initialization procedure\&. "
.ti -1c
.RI "void \fB_sir_initmutex_si_once\fP (void)"
.br
.RI "Initializes a specific mutex\&. "
.ti -1c
.RI "void \fB_sir_initmutex_fc_once\fP (void)"
.br
.RI "Initializes a specific mutex\&. "
.ti -1c
.RI "void \fB_sir_initmutex_ts_once\fP (void)"
.br
.RI "Initializes a specific mutex\&. "
.ti -1c
.RI "void \fB_sir_initmutex\fP (\fBsirmutex_t\fP *mutex)"
.br
.RI "Initializes a specific mutex\&. "
.ti -1c
.RI "bool \fB_sir_once\fP (\fBsironce_t\fP *once, \fBsir_once_fn\fP func)"
.br
.RI "Executes only one time\&. "
.ti -1c
.RI "bool \fB_sir_logv\fP (\fBsir_level\fP level, const \fBsirchar_t\fP *format, va_list args)"
.br
.RI "Core output formatting\&. "
.ti -1c
.RI "bool \fB_sir_dispatch\fP (\fBsirinit\fP *si, \fBsir_level\fP level, \fBsirbuf\fP *buf)"
.br
.RI "Output dispatching\&. "
.ti -1c
.RI "const \fBsirchar_t\fP * \fB_sir_format\fP (bool styling, \fBsir_options\fP opts, \fBsirbuf\fP *buf)"
.br
.RI "Specific destination formatting\&. "
.ti -1c
.RI "int \fB_sir_syslog_maplevel\fP (\fBsir_level\fP level)"
.br
.RI "Maps a \fBsir_level\fP to a \fIsyslog\fP level\&. "
.ti -1c
.RI "void \fB_sir_syslog_open\fP (const char *app_name, \fBsir_syslog_dest\fP *ctx)"
.br
.RI "Called upon initialization of the library; does any necesssary connecting/opening handles, etc\&. "
.ti -1c
.RI "bool \fB_sir_syslog_write\fP (\fBsir_level\fP level, const \fBsirbuf\fP *buf, \fBsir_syslog_dest\fP *ctx)"
.br
.RI "Abstraction for writing to platform-specific implementations of syslog-type facilities (e\&.g\&.,) \fCos_log\fP on macOS\&. "
.ti -1c
.RI "void \fB_sir_syslog_close\fP (\fBsir_syslog_dest\fP *ctx)"
.br
.RI "Called upon shutdown of the library; does any necessary cleaning up/closing handles, etc\&. "
.ti -1c
.RI "const \fBsirchar_t\fP * \fB_sir_levelstr\fP (\fBsir_level\fP level)"
.br
.RI "Converts a \fBsir_level\fP to its human-readable form\&. "
.ti -1c
.RI "bool \fB_sir_formattime\fP (time_t now, \fBsirchar_t\fP *buffer, const \fBsirchar_t\fP *format)"
.br
.RI "Formats the current time as a string\&. "
.ti -1c
.RI "bool \fB_sir_getlocaltime\fP (time_t *tbuf, long *nsecbuf)"
.br
.RI "Retrieves the current local time w/ optional milliseconds\&. "
.ti -1c
.RI "pid_t \fB_sir_getpid\fP (void)"
.br
.RI "Returns the current process identifier\&. "
.ti -1c
.RI "pid_t \fB_sir_gettid\fP (void)"
.br
.RI "Returns the current thread identifier\&. "
.ti -1c
.RI "bool \fB_sir_getthreadname\fP (char name[16])"
.br
.RI "Returns the current thread's name\&. "
.ti -1c
.RI "bool \fB_sirmutex_create\fP (\fBsirmutex_t\fP *mutex)"
.br
.RI "Creates/initializes a new mutex\&. "
.ti -1c
.RI "bool \fB_sirmutex_trylock\fP (\fBsirmutex_t\fP *mutex)"
.br
.RI "Determines if a mutex is locked without waiting\&. "
.ti -1c
.RI "bool \fB_sirmutex_lock\fP (\fBsirmutex_t\fP *mutex)"
.br
.RI "Attempts to lock a mutex and waits indefinitely\&. "
.ti -1c
.RI "bool \fB_sirmutex_unlock\fP (\fBsirmutex_t\fP *mutex)"
.br
.RI "Unlocks a previously locked mutex\&. "
.ti -1c
.RI "bool \fB_sirmutex_destroy\fP (\fBsirmutex_t\fP *mutex)"
.br
.RI "Destroys a mutex\&. "
.ti -1c
.RI "bool \fB_sir_validstyle\fP (\fBsir_textstyle\fP style, uint32_t *pattr, uint32_t *pfg, uint32_t *pbg)"
.br
.RI "The maximum size of a color escape code sequence in bytes\&. "
.ti -1c
.RI "\fBsir_textstyle\fP \fB_sir_gettextstyle\fP (\fBsir_level\fP level)"
.br
.RI "Retrieves the override \fBsir_textstyle\fP for a \fBsir_level\fP if one is set\&. "
.ti -1c
.RI "\fBsir_textstyle\fP \fB_sir_getdefstyle\fP (\fBsir_level\fP level)"
.br
.RI "Retrieves the default \fBsir_textstyle\fP for a \fBsir_level\fP\&. "
.ti -1c
.RI "bool \fB_sir_settextstyle\fP (\fBsir_level\fP level, \fBsir_textstyle\fP style)"
.br
.RI "Sets the \fBsir_textstyle\fP for a \fBsir_level\fP\&. "
.ti -1c
.RI "bool \fB_sir_resettextstyles\fP (void)"
.br
.RI "Resets all per-level \fBsir_textstyle\fP to default\&. "
.ti -1c
.RI "uint16_t \fB_sir_getprivstyle\fP (uint32_t style)"
.br
.RI "Retrieves the opaque numeric value for a component part of a \fBsir_textstyle\fP\&. "
.ti -1c
.RI "bool \fB_sir_formatstyle\fP (\fBsir_textstyle\fP style, \fBsirchar_t\fP *buf, size_t size)"
.br
.RI "Combines component parts of a platform text style value into its final form\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "static \fBsir_level_style_pair\fP \fBsir_override_style_map\fP []"
.br
.RI "Overrides for \fBsir_level\fP <-> \fBsir_textstyle\fP mappings\&. "
.ti -1c
.RI "static const \fBsir_level_str_pair\fP \fBsir_level_str_map\fP []"
.br
.RI "Mapping of \fBsir_level\fP <-> string representation (\fBsirconfig\&.h\fP) "
.ti -1c
.RI "static const \fBsir_style_16color_pair\fP \fBsir_style_16color_map\fP []"
.br
.RI "Mapping of \fBsir_textstyle\fP <-> values used to generate styled terminal output for 4-bit (16 color) mode\&. "
.in -1c
.SH "Detailed Description"
.PP 
libsir's guts\&. 


.SH "Data Structure Documentation"
.PP 
.SH "struct sirfile"
.PP 
Log file data\&. 
.PP
Definition at line \fB205\fP of file \fBsirtypes\&.h\fP\&.
.SH "struct sirfcache"
.PP 
Log file cache\&. 
.PP
Definition at line \fB214\fP of file \fBsirtypes\&.h\fP\&.
.SH "struct sirbuf"
.PP 
Formatted output sent to destinations\&. 
.PP
Definition at line \fB220\fP of file \fBsirtypes\&.h\fP\&.
.SH "struct sir_level_style_pair"
.PP 
\fBsir_level\fP <-> default \fBsir_textstyle\fP mapping\&. 
.PP
Definition at line \fB234\fP of file \fBsirtypes\&.h\fP\&.
.PP
\fBData Fields:\fP
.RS 4
const \fBsir_level\fP \fIlevel\fP The level for which the style applies\&. 
.br
.PP
uint32_t \fIstyle\fP The default value\&. 
.br
.PP
.RE
.PP
.SH "struct sir_level_str_pair"
.PP 
\fBsir_level\fP <-> string representation mapping (\fBsirconfig\&.h\fP) 
.PP
Definition at line \fB240\fP of file \fBsirtypes\&.h\fP\&.
.SH "struct sir_style_16color_pair"
.PP 
Public (\fBsir_textstyle\fP) <-> values used to generate styled terminal output\&. 
.PP
Definition at line \fB246\fP of file \fBsirtypes\&.h\fP\&.
.PP
\fBData Fields:\fP
.RS 4
const uint32_t \fIfrom\fP The public text style flag(s)\&. 
.br
.PP
const uint16_t \fIto\fP The internal value\&. 
.br
.PP
.RE
.PP
.SH "struct sir_thread_err"
.PP 
Error type\&. 
.PP
Definition at line \fB259\fP of file \fBsirtypes\&.h\fP\&.
.SH "struct sir_update_config_data"
.PP 
Encapsulates dynamic updating of current configuration\&. 
.PP
Definition at line \fB272\fP of file \fBsirtypes\&.h\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define _sir_notnull(addr)   (NULL != addr)"

.PP
Validates a pointer-to-pointer, pointer, pointer to function, etc\&. but ignores whether it's invalid\&. 
.PP
Definition at line \fB108\fP of file \fBsirhelpers\&.h\fP\&.
.SS "#define SIR_ESC_START   '\\x1b['"

.PP
Escape sequences: 16 colors: \\033[<dim=0\&.\&.2>;<fg=30\&.\&.37, 90\&.\&.97>;<bg=40\&.\&.47, 100\&.\&.107>m 256 colors: \\033[<fg=38|bg=48>;5;<0\&.\&.255>m 24-bit RGB: \\033[<fg=38|bg=48>;2;<R=0\&.\&.255>;<G=0\&.\&.255>;<B=0\&.\&.255>m Clear all: \\033[0m
.PP
Note: evidently, you can chain these sequences to set both fore and back simultaneously: \\033[38;5;128;48;5;206m
.PP
.IP "\(bu" 2
30–37, 90–97 ('bright'): Set foreground color (number = color ID)
.IP "\(bu" 2
38: Set foreground color (with pattern to follow: 256 or 24-bit RGB color)
.IP "\(bu" 2
39: Set default foreground color
.IP "\(bu" 2
40–47, 100–107 ('bright'): Set background color (number = color ID)
.IP "\(bu" 2
48: Set background color (with pattern to follow: 256 or 24-bit RGB color)
.IP "\(bu" 2
49: Set default background color === to test =====================================================================================
.IP "\(bu" 2
4: Underline (off: 24)
.IP "\(bu" 2
5: Blinking (off: 25)
.IP "\(bu" 2
51: Framed (off: 54)
.IP "\(bu" 2
52: Encircled (off: 54)
.IP "\(bu" 2
53: Overlined (off: 55)
.IP "\(bu" 2
1: Bold (off: 21)
.PP
.PP
The 24-bit RGB spectrum is laid out as follows:
.PP
0x00-0x07: standard colors (same as the 4-bit colors) 0x08-0x0F: high intensity colors 0x10-0xE7: 6 × 6 × 6 cube (216 colors): 16 + 36 × r + 6 × g + b (0 ≤ r, g, b ≤ 5) 0xE8-0xFF: grayscale from black to white in 24 steps 
.PP
Definition at line \fB75\fP of file \fBsirtextstyle\&.h\fP\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBsir_mutex_id\fP"

.PP
Mutex <-> protected section mapping\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fI_SIRM_INIT \fP\fP
The \fBsirinit\fP section\&. 
.TP
\fB\fI_SIRM_FILECACHE \fP\fP
The \fBsirfcache\fP section\&. 
.TP
\fB\fI_SIRM_TEXTSTYLE \fP\fP
The \fBsir_level_style_pair\fP section\&. 
.PP
Definition at line \fB252\fP of file \fBsirtypes\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "bool _sir_fileexists (const char *restrict path)"

.PP
Determines if a file or directory exists in the filesystem\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP null-terminated string containing the path to test\&.
.RE
.PP
\fBReturns\fP
.RS 4
true TODO 
.PP
false TODO 
.RE
.PP

.PP
Definition at line \fB44\fP of file \fBsirfilesystem\&.c\fP\&.
.SS "int _sir_fopen (FILE *restrict *restrict streamptr, const \fBsirchar_t\fP *restrict filename, const \fBsirchar_t\fP *restrict mode)"

.PP
Wrapper for fopen/fopen_s\&. Determines which one to use based on preprocessor macros\&. 
.PP
Definition at line \fB182\fP of file \fBsirhelpers\&.c\fP\&.
.SS "int _sir_getchar (void)"

.PP
A portable 'press any key to continue' implementation; On Windows, uses _getch()\&. otherwise, uses tcgetattr()/tcsetattr() and getchar()\&. 
.PP
Definition at line \fB233\fP of file \fBsirhelpers\&.c\fP\&.
.SS "bool _sir_getcwd (char *restrict buffer, size_t size)"

.PP
Obtains the current working directory for the calling process\&. 
.PP
\fBNote\fP
.RS 4
The working directory is not necessarily the same as the directory that the binary resides in\&. Use \fB_sir_getappdir\fP to obtain that path\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP Pointer to a string of characters not less than \fBSIR_MAXPATH\fP in length\&. 
.br
\fIsize\fP TODO 
.RE
.PP
\fBReturns\fP
.RS 4
true TODO 
.PP
false TODO 
.RE
.PP

.PP
Definition at line \fB65\fP of file \fBsirfilesystem\&.c\fP\&.
.SS "\fBsir_textstyle\fP _sir_gettextstyle (\fBsir_level\fP level)"

.PP
Retrieves the override \fBsir_textstyle\fP for a \fBsir_level\fP if one is set\&. Otherwise, returns the default text style for that level\&. 
.PP
Definition at line \fB71\fP of file \fBsirtextstyle\&.c\fP\&.
.SS "struct tm * _sir_localtime (const time_t *restrict timer, struct tm *restrict buf)"

.PP
Wrapper for localtime/localtime_s\&. Determines which one to use based on preprocessor macros\&. 
.PP
Definition at line \fB206\fP of file \fBsirhelpers\&.c\fP\&.
.SS "int _sir_strncat (\fBsirchar_t\fP *restrict dest, size_t destsz, const \fBsirchar_t\fP *restrict src, size_t count)"

.PP
Wrapper for strncat/strncat_s\&. Determines which one to use based on preprocessor macros\&. 
.PP
Definition at line \fB158\fP of file \fBsirhelpers\&.c\fP\&.
.SS "int _sir_strncpy (\fBsirchar_t\fP *restrict dest, size_t destsz, const \fBsirchar_t\fP *restrict src, size_t count)"

.PP
Wrapper for strncpy/strncpy_s\&. Determines which one to use based on preprocessor macros\&. 
.PP
Definition at line \fB134\fP of file \fBsirhelpers\&.c\fP\&.
.SS "bool _sir_validstyle (\fBsir_textstyle\fP style, uint32_t * pattr, uint32_t * pfg, uint32_t * pbg)"

.PP
The maximum size of a color escape code sequence in bytes\&. Validates a \fBsir_textstyle\fP and splits it into its component parts\&. 
.PP
Definition at line \fB41\fP of file \fBsirtextstyle\&.c\fP\&.
.SS "bool _sirfile_archive (\fBsirfile\fP * sf, const \fBsirchar_t\fP * newpath)"

.PP
Definition at line \fB307\fP of file \fBsirfilecache\&.c\fP\&.
.SH "Variable Documentation"
.PP 
.SS "const \fBsir_level_str_pair\fP sir_level_str_map[]\fC [static]\fP"
\fBInitial value:\fP.PP
.nf
= {
    {SIRL_EMERG,   "emrg" },
    {SIRL_ALERT,   "alrt" },
    {SIRL_CRIT,    "crit" },
    {SIRL_ERROR,   "erro" },
    {SIRL_WARN,    "warn" },
    {SIRL_NOTICE,  "noti" },
    {SIRL_INFO,    "info" },
    {SIRL_DEBUG,   "debg" }
}
.fi

.PP
Mapping of \fBsir_level\fP <-> string representation (\fBsirconfig\&.h\fP) \fB_sir_levelstr\fP obtains string representations from this array for output formatting\&.
.PP
\fBAttention\fP
.RS 4
Entries \fImust\fP remain in numeric ascending order (by SIRL_*); binary search is used to look up entries based on those values\&. 
.RE
.PP

.PP
Definition at line \fB75\fP of file \fBsirmaps\&.h\fP\&.
.SS "\fBsir_level_style_pair\fP sir_override_style_map[]\fC [static]\fP"
\fBInitial value:\fP.PP
.nf
= {
    {SIRL_EMERG,  SIRS_INVALID},
    {SIRL_ALERT,  SIRS_INVALID},
    {SIRL_CRIT,   SIRS_INVALID},
    {SIRL_ERROR,  SIRS_INVALID},
    {SIRL_WARN,   SIRS_INVALID},
    {SIRL_NOTICE, SIRS_INVALID},
    {SIRL_INFO,   SIRS_INVALID},
    {SIRL_DEBUG,  SIRS_INVALID}
}
.fi

.PP
Overrides for \fBsir_level\fP <-> \fBsir_textstyle\fP mappings\&. \fBsir_settextstyle\fP sets (overrides) the style values in this array at runtime; only the SIRL_* values are constant\&.
.PP
\fBsir_default_style_map\fP in \fBsirdefaults\&.h\fP contains the constant, default styles for each level\&.
.PP
\fBAttention\fP
.RS 4
Entries \fImust\fP remain in numeric ascending order (by SIRL_*); binary search is used to look up entries based on those values\&. 
.RE
.PP

.PP
Definition at line \fB55\fP of file \fBsirmaps\&.h\fP\&.
.SS "const \fBsir_style_16color_pair\fP sir_style_16color_map[]\fC [static]\fP"

.PP
Mapping of \fBsir_textstyle\fP <-> values used to generate styled terminal output for 4-bit (16 color) mode\&. 
.PP
\fBAttention\fP
.RS 4
Entries \fImust\fP remain in numeric ascending order (by SIRS_*); binary search is used to look up entries based on those values\&. 
.RE
.PP

.PP
Definition at line \fB94\fP of file \fBsirmaps\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for libsir from the source code\&.
